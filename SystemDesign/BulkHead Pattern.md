## BulkHead 模式

BulkHead 模式是在架构设计中常用的一种failover tolerant模式。BulkHead模式中，应用的元素被池限制，如果池里的一个失败了，不会影响到其他的应用。命名源自于，船的保险仓，即使一个进水了，也不会使船沉没。

### Context And Problem

现代系统一般都有多个服务，一个服务有多个消费者。一个服务的过载或者失败将会影响所有的消费者。

此外，一个消费者会同时请求多个服务，每个请求都会消耗资源。当消费者请求一个服务的时候配置错误或者没有响应，消耗的资源可能一段时间内都不会释放。当请求持续，这些资源都被消耗了。比如，客户的连接池被耗尽。这个节点时，这个客户端对其他服务的请求也被影响了。最终这个客户端再也不能给任何服务发送消息了，而不只是最早fail的服务。

### Solution 

把服务根据用户的load和可用性要求而分区放入不同的组。这个设计隔离了失败，在某些失败的情况下，让系统对某些服务功能保持可用。

一个用户也可以对资源分区，保证访问一个服务的失败，不会影响调用其他服务的资源。比如，用户访问多个服务可用给每个服务设计连接池。如果一个服务开始失败，只影响这个服务的连接池，其他服务的请求保持正常。

这个模式的优点包括：

* 把用户和服务对级联失败隔离。一个问题只影响一个客户或服务，保证整个系统不因此失败
* 在一个服务失败时，允许你保留系统的某些功能。其他服务和功能保证继续运行
* 允许你部署的时候，其他服务能继续运行。一个高优先级的连接池可以使用高优先级的服务配置

### Issues And Considerations

* 围绕业务和技术角度来设计分区
* 当对服务和资源分区的时候，要考虑隔离级别，性能，消耗和可管理性
* 考虑结合其他模式，比如重试，circuit break和throttling，构建更复杂的错误处理
* 分区的方式，考虑使用进程，线程池和信号量。比如 [resilience4j](https://github.com/resilience4j/resilience4j) 和[Polly](https://github.com/App-vNext/Polly) 框架来实现
* 分区服务的时候，考虑通过部署到不同的VM，容器或者进程。容器在资源隔离和较合理的负载之间提供了很好的平衡。
* 使用异步消息通信的服务可以通过不同的消息队列来隔离。每个队列可以有一组指定的实例来处理消息，或者一组单独的实例使用算法来处理和分发消息
* 定义隔离的粒度。比如，如果你要对租户分区，可以一个租户一个区，也可以多个租户一个区
* SLA,监控每个分区

### When to use this Pattern

使用这个模式：

* 后端服务分组，隔离资源，特别是应用需要在某些服务不可用的时候还提供一些功能
* 对特别的用户和普通用户隔离
* 保护系统，以免级联失败

不适用：

* 对资源高效利用有要求的系统
* 系统不能接受更复杂的改造

### Example

K8s对一个服务的独立容器配置，CPU和内存限制

``` yaml
apiVersion: v1
kind: Pod
metadata:
	name: done-management
spec:
	containers:
	-	name: drone-management-container
		image: drone-service
		resources:
			requests:
				memory: "64Mi"
				cpu: "250m"
			limits:
				memory: "128Mi"
				cpu: "1"
```

### 相关阅读

Circuit Breaker

Retry Pattern

Throttling Pattern

